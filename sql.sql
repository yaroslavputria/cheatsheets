1. Integer, a positive or negative whole number 
2. Text, a text string 
3. Date, the date formatted as YYYY-MM-DD for the year, month, and day 
4. Real, a decimal value 


CREATE TABLE creates a new table.
INSERT INTO adds a new row to a table.
SELECT queries data from a table. // DISTINCT - без повторів
UPDATE edits a row in a table.
ALTER TABLE changes an existing table.
DELETE FROM deletes rows from a table.

= equals
!= not equals
> greater than
< less than
>= greater than or equal to
<= less than or equal to

A% matches all movies with names that begin with "A"
%a matches all movies that end with "a"

_ any character or digit

ORDER BY:
DESC - high to low or Z-A
ASC - low to high or A-Z

SELECT DISTINCT genre FROM movies;

SELECT * FROM movies WHERE imdb_rating > 8;

SELECT * FROM movies WHERE name LIKE 'Se_en';

SELECT * FROM movies WHERE name LIKE '%man%';

SELECT * FROM movies WHERE name BETWEEN 'A' AND 'J';
SELECT * FROM movies WHERE year BETWEEN 1990 AND 2000;

SELECT * FROM movies WHERE year BETWEEN 1990 AND 2000 AND genre = 'comedy';

SELECT * FROM movies WHERE genre = 'comedy' OR year < 1980;

SELECT * FROM movies ORDER BY imdb_rating DESC;

SELECT * FROM movies ORDER BY imdb_rating ASC LIMIT 3;


Создание таблицы, добавление, изменение и удаление записей при помощи sql

Создадим таблицу «cities»:
	CREATE TABLE cities(id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, name CHAR(100) NOT NULL,  
	city CHAR(100) NOT NULL) character set utf8;

Добавим несколько записей:
	INSERT INTO cities (city, name) VALUE(`Москва`, `Локомотив`), (`Москва`, `Спартак`), (`Казань`, `Рубин`);

Изменение записи:
	UPDATE cities SET city = `Белгород`, name=`Салют` WHERE name=`Рубин`;

Удаление записи:
	DELETE FROM cities where id=1;

Выбор данных из таблицы

Выбрать все записи из таблицы «cities»:
	SELECT * FROM cities

Вычисляемые поля: вывести зарплату, надбавку, общую сумму и процент надбавки из таблицы:
	SELECT name, rise, salary, salary+rise, rise*100/salary FROM teacher

Получаем произвольную строку в результате выполнения запроса:
	SELECT `Преподаватель `, name, ` имеет ставку: `, salary from teacher

Выбираем, без повторений, все города из таблицы:
	SELECT DISTINCT city FROM cities

Иногда, чтобы не писать длинные названия таблиц и полей или для наглядности, лучше, используя «AS», задать им синоним:
	SELECT name AS `Имя` FROM teacher WHERE post=LOWER(`декан`)
	(LOWER — переводит текст в нижний регистр, UPPER — в верхний)

Использование «NOT» (Выбрать все города кроме Москвы):
	SELECT * FROM cities WHERE  NOT city=`Москва`

Вывести города названия которых начинается на букву, расположенную до буквы «С»:
	SELECT city FROM cities WHERE city<`С`

Примеры с «LIKE»-ом (Выбрать города начинающиеся на букву «C»)
	SELECT * FROM cities WHERE city LIKE `C%`

Выбрать города в названии которых встречается две буквы «а»:
	SELECT * FROM `cities` WHERE city LIKE `%а%а%`

Выбрать города которые начинаются на «Б» и третья буква «л»:
	SELECT * FROM `cities` WHERE city LIKE `Б_л%`

Работа с полями типа «DATE» и «DATETIME»

Выбрать преподавателей, принятых на работу позже 02.04.2013:
	SELECT * FROM `teacher` WHERE datep>`2013-04-02`

Выбрать преподавателей, принятых на работу между 01.04.2013 и 03.04.2013:
	SELECT * FROM teacher WHERE datep BETWEEN (`2013-04-01`) and (`2013-04-03`)

Представление даты и времени в «нормальном» виде(13.11.2013 16:15:14):
SELECT DATE_FORMAT(datep, `%d.%m.%Y %H:%i:%s`) AS `дата`, name FROM teacher

==================================================================
==================================================================
==================================================================
==================================================================
==================================================================

create database имя_базы_данных;

use имя_базы_данных;

create table имя_таблицы (имя_первого_столбца тип, имя_второго_столбца тип, …, имя_последнего_столбца тип );

show databases; — показать все имеющиеся БД.

show tables; — показать список таблиц текущей БД (предварительно ее надо выбрать с помощью оператора use).

describe имя_таблицы; — показать описание столбцов указанной таблицы

drop database имя_базы данных; — удалить БД.

drop table имя_таблицы; -удалить таблицу.

AUTO_INCREMENT — высчитывает максимальное значение этого столбца, полученное значение увеличивает на 1 и заносит его в столбец.

PRIMARY KEY ()

FOREIGN KEY (имя_столбца_которое_является_внешним_ключом) REFERENCES имя_таблицы_родителя (имя_столбца_родителя); 

INSERT INTO имя_таблицы VALUES (‘значение_первого_столбца’, ‘значение_второго_столбца’, …, ‘значение_последнего_столбца’);

INSERT INTO имя_таблицы (‘имя_столбца’, ‘имя_столбца’) VALUES (‘значение_первого_столбца’,’значение_второго_столбца’);

SELECT что_выбрать FROM откуда_выбрать;

SELECT * FROM откуда_выбрать; — выбрать все столбцы таблицы

SELECT имя_столбца FROM имя_таблицы ORDER BY имя_столбца_сортировки; — сортировка

SELECT имя_столбца FROM имя_таблицы ORDER BY имя_столбца_сортировки; — сортировка DESC;

SELECT имя_столбца FROM имя_таблицы WHERE условие;

Необычные операторы:

BETWEEN меньшее_число AND большее_число — отбираются значения, находящиеся между указанными.

IS NOT NULL (IS NULL) — отбираются строки, (не) имеющие значения в указанном поле.

IN (NOT IN) — отбираются значения, (кроме) соответствующие указанным

LIKE (NOT LIKE) — отбираются значения, (не) соответствующие образцу. Самый распространенный метасимвол — %. Он означает любые символы. Например, если нам надо найти слова, начинающиеся с букв «вел», то мы напишем LIKE ‘вел%’, а если мы хотим найти слова, которые содержат символы «клуб», то мы напишем LIKE ‘%клуб%’.

SELECT имя_столбца FROM имя_таблицы WHERE часть условия IN (SELECT имя_столбца FROM имя_таблицы WHERE часть условия IN (SELECT имя_столбца FROM имя_таблицы WHERE условие) ) ; — подзапросы

SELECT имена_столбцов_таблицы_1, имена_столбцов_таблицы_2 FROM имя_таблицы_1, имя_таблицы_2; — объединение

SELECT имя_таблицы_1.имя_столбца1_таблицы_1, имя_таблицы_1.имя_столбца2_таблицы_1, имя_таблицы_2.имя_столбца1_таблицы_2, имя_таблицы_2.имя_столбца2_таблицы_2 FROM имя_таблицы_1, имя_таблицы_2 WHERE имя_таблицы_1.имя_столбца_по_которому_объединяем = имя_таблицы_2.имя_столбца_по_которому_объединяем;

SELECT имя_таблицы_1.имя_столбца, имя_таблицы_2.имя_столбца FROM имя_таблицы_1 ТИП ОБЪЕДИНЕНИЯ имя_таблицы_2 ON условие_объединения;— где ТИП ОБЪЕДИНЕНИЯ — либо LEFT OUTER JOIN, либо RIGHT OUTER JOIN. Чтобы взять все строки с таблицы, а не только полные.

COUNT() – подсчет количества строк в таблице


 
SELECT COUNT(имя_столбца) FROM имя_таблицы;

SELECT имя_столбца COUNT(имя_столбца) FROM имя_таблицы GROUP BY имя_столбца;

SELECT имя_столбца COUNT(имя_столбца) FROM имя_таблицы GROUP BY имя_столбца HAVING COUNT условие; — HAVING исполняет функции

ALTER TABLE имя_таблицы ADD COLUMN имя_столбца тип; — добавление столбца.

FIRST — новый столбец будет первым, и AFTER — указывает после какого столбца поместить новый.

UPDATE имя_таблицы SET имя_столбца=значение_столбца WHERE условие — для обновления уже существующих данных.

ALTER TABLE имя_таблицы CHANGE старое_имя_столбца новое_имя_столбца тип; — измение названия столбца.

ALTER TABLE имя_таблицы MODIFY имя_столбца новый_тип; — изминение типа данных столбца.

DELETE FROM имя_таблицы WHERE условие; — удаление строк из столбца.

AVG() — Функция возвращает среднее значение столбца.

COUNT() — Функция возвращает число строк в столбце.

MAX() — Функция возвращает самое большое значение в столбце.

MIN() — Функция возвращает самое маленькое значение в столбце.

SUM() — Функция возвращает сумму значений столбца.

SELECT имя_таблицы_1.имя_столбца* имя_таблицы_2.имя_столбца AS имя _вычисляемого_столбца FROM имя_таблицы_1, имя_таблицы_2 – создание дополнительного столбца для вывода данных. Ее нельзя использовать, так как она не находиться в какой-либо таблице. Для таких случаев существуют Представления.

CREATE VIEW имя_представления AS запрос; — создание представления.

CONCAT(str1,str2…) Возвращает строку, созданную путем объединения аргументов (аргументы указываются в скобках — str1,str2…). Добавляем пробел » «, как аргумент, для читабельности.

SELECT CONCAT_WS(‘ ‘, имя_столбца1, имя_столбца2) FROM имя_таблицы; — если аргументов много, используем этот синтаксис для рациональности. Первым аргументом ставим разделитель.

INSERT(str, pos, len, new_str) Возвращает строку str, в которой подстрока, начинающаяся с позиции pos и имеющая длину len символов, заменена подстрокой new_str.

LPAD(str, len, dop_str) Возвращает строку str, дополненную слева строкой dop_str до длины len.

RPAD(str, len, dop_str) Возвращает строку str, дополненную справа строкой dop_str до длины len.

LTRIM(str) Возвращает строку str, в которой удалены все начальные пробелы. Эта строковая функция удобна для корректного отображения информации в случаях, когда при вводе данных допускаются случайные пробелы.

RTRIM(str) Возвращает строку str, в которой удалены все конечные пробелы.

TRIM(str) Возвращает строку str, в которой удалены все начальные и конечные пробелы.

LOWER(str) Возвращает строку str, в которой все символы переведены в нижний регистр. С русскими буквами работает некорректно, поэтому лучше не применять.

UPPER(str) Возвращает строку str, в которой все символы переведены в верхний регистр. С русскими буквами так же лучше не применять.

LENGTH(str) Возвращает длину строки str.

LEFT(str, len) Возвращает len левых символов строки str.

RIGHT(str, len) Возвращает len правых символов строки str.

REPEAT(str, n) Возвращает строку str n-количество раз.

REPLACE(str, pod_str1, pod_str2) Возвращает строку str, в которой все подстроки pod_str1 заменены подстроками pod_str2.

REVERSE(str) Возвращает строку str, записанную в обратном порядке.

LOAD_FILE(file_name) Эта функция читает файл file_name и возвращает его содержимое в виде строки.

CURDATE(), CURTIME() и NOW() — Первая функция возвращает текущую дату, вторая — текущее время, а третья — текущую дату и время.

ADDDATE(date, INTERVAL value) — Функция возвращает дату date, к которой прибавлено значение value. Значение value может быть отрицательным, тогда итоговая дата уменьшится. В качестве значения value могут выступать не только дни, но и недели (WEEK), месяцы (MONTH), кварталы (QUARTER) и годы (YEAR).

SUBDATE(date, INTERVAL value) — функция идентична предыдущей, но производит операцию вычитания, а не сложения.

PERIOD_ADD(period, n) — функция добавляет n месяцев к значению даты period. Нюанс: значение даты должно быть представлено в формате YYYYMM.

TIMESTAMPADD(interval, n, date) — функция добавляет к дате date временной интервал n, значения которого задаются параметром interval. Возможные значения параметра interval: FRAC_SECOND — микросекунды SECOND — секунды MINUTE — минуты HOUR — часы DAY — дни WEEK — недели MONTH — месяцы QUARTER — кварталы YEAR – годы.

TIMEDIFF(date1, date2) — вычисляет разницу в часах, минутах и секундах между двумя датами.


 
DATEDIFF(date1, date2) — вычисляет разницу в днях между двумя датами.

PERIOD_DIFF(period1, period2) — функция вычисляет разницу в месяцах между двумя датами, представленными в формате YYYYMM.

TIMESTAMPDIFF(interval, date1, date2) — функция вычисляет разницу между датами date2 и date1 в единицах, указанных в параметре interval.

SUBTIME(date, time) функция вычитает из времени date время time.

DATE(datetime) — возвращает дату, отсекая время.

TIME(datetime) — возвращает время, отсекая дату.

TIMESTAMP(date) — функция принимает дату date и возвращает полный вариант со временем.

DAY(date) и DAYOFMONTH(date) — функции-синонимы, возвращают из даты порядковый номер дня месяца.

DAYNAME(date), DAYOFWEEK(date) и WEEKDAY(date) — функции возвращают день недели, первая — его название, вторая — номер дня недели (отсчет от 1 — воскресенье до 7 — суббота), третья — номер дня недели (отсчет от 0 — понедельник, до 6 – воскресенье.

WEEK(date), WEEKOFYEAR(datetime) — обе функции возвращают номер недели в году, первая для типа date, а вторая — для типа datetime, у первой неделя начинается с воскресенья, у второй — с понедельника.

MONTH(date) и MONTHNAME(date) — обе функции возвращают значения месяца. Первая — его числовое значение (от 1 до 12), вторая — название месяца.

QUARTER(date) — функция возвращает значение квартала года (от 1 до 4).

YEAR(date) — функция возвращает значение года (от 1000 до 9999).

DAYOFYEAR(date) возвращает порядковый номер дня в году (от 1 до 366).

HOUR(datetime) возвращает значение часа для времени (от 0 до 23).

MINUTE(datetime) возвращает значение минут для времени (от 0 до 59).

SECOND(datetime) возвращает значение секунд для времени (от 0 до 59).

EXTRACT(type FROM date) возвращает часть date определяемую параметром type:

SELECT EXTRACT(YEAR FROM ‘2011-04-17 23:15:18’) AS year,

EXTRACT(MONTH FROM ‘2011-04-17 23:15:18’) AS mon,

EXTRACT(DAY FROM ‘2011-04-17 23:15:18’) AS day,

EXTRACT(HOUR FROM ‘2011-04-17 23:15:18’) AS hour,

EXTRACT(MINUTE FROM ‘2011-04-17 23:15:18’) AS min,

EXTRACT(SECOND FROM ‘2011-04-17 23:15:18’) AS sec;

TO_DAYS(date) и FROM_DAYS(n) взаимообратные функции. Первая преобразует дату в количество дней, прошедших с нулевого года. Вторая, наоборот, принимает число дней, прошедших с нулевого года и преобразует их в дату.

UNIX_TIMESTAMP(date) и FROM_UNIXTIME(n) взаимообратные функции. Первая преобразует дату в количество секунд, прошедших с 1 января 1970 года. Вторая, наоборот, принимает число секунд, с 1 января 1970 года и преобразует их в дату.

TIME_TO_SEC(time) и SEC_TO_TIME(n) взаимообратные функции. Первая преобразует время в количество секунд, прошедших от начала суток. Вторая, наоборот, принимает число секунд с начала суток и преобразует их во время.

MAKEDATE(year, n) функция принимает год и номер дня в году и преобразует их в дату.

CREATE PROCEDURE имя_процедуры (параметры) begin операторы end – создание процедуры.

DELIMITER // — точка с запятой означает конец запроса и отправляет его на выполнение, что в данном случае неприемлемо. Поэтому, прежде, чем написать процедуру необходимо переопределить разделитель с ; на «//», чтобы запрос не отправлялся раньше времени. Таким образом, мы указали СУБД, что выполнять команды теперь следует после //. Следует помнить, что переопределение разделителя осуществляется только на один сеанс работы, т.е. при следующем сеансе работы с MySql разделитель снова станет точкой с запятой и при необходимости его придется снова переопределять.

call имя_процедуры(параметры)// — вызов процедуры.

DROP PROCEDURE название_процедуры – удаление процедуры.

IF  EXISTS — берет подзапрос, как аргумент, и оценивает его как верный, если подзапрос возвращает какие-либо записи и неверный, если тот не делает этого.

SHOW PROCEDURE STATUS — позволяет просмотреть список имеющихся хранимых процедур. Правда просматривать этот список не очень удобно, т.к. по каждой процедуре выдается информация об имени БД, к которой процедура принадлежит, ее типе, учетной записи, от имени которой была создана процедура, о дате создания и изменения процедуры и т.д. И все-таки, если вам необходимо посмотреть, какие процедуры у вас есть, то стоит воспользоваться этим оператором.

SHOW CREATE PROCEDURE имя_процедуры — позволяет получить информацию о конкретной процедуре, в частности просмотреть ее код. Вид для просмотра также не очень удобный, но разобраться можно.

SELECT * FROM proc//

db — имя БД, в которую сохранена процедура.

name — имя процедуры.

param_list — список параметров процедуры.

body — тело процедуры.

comment — комментарий к хранимой процедуре.

SELECT name FROM proc WHERE db=”имя_базы_данных”// — список процедур в БД.

SELECT body FROM proc WHERE name=‘имя_процедуры‘// — просмотр кода процедуры.

COMMENT ‘здесь комментарий’. — сразу после списка параметров, но еще до начала тела хранимой процедуры.

CREATE PROCEDURE имя_процедуры (параметры) begin IF(условие) THEN запрос 1; ELSE запрос 2; END IF; end //

ELSEIF(условие) THEN запрос 2;